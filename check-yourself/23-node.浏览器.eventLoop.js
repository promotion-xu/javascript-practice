// 异步运行机制
// (1). 所有任务都会在主线程上执行，形成一个执行栈
// (2). 主线程之外，还存在一个任务队列，只要异步任务有了结果，就会在主线程上放一个事件
// (3). 一旦主线程任务执行完毕，就会读取任务队列，进入主线程，开始执行
// (4). 主线程不断重复第三步

// 总结：
// 1. 浏览器的Event Loop 和 NodeJS 的Event Loop 是不同的，机制也不一样
// 2. 浏览器可以理解为只有一个宏任务和一个微任务队列,先执行Script代码，执行完同步代码调用栈清空后，
// 会从微任务队列依次取出放入调用栈，微任务清空后，
// 3. 从宏任务队列中只取位于队首的任务放入调用栈执行，注意这里是和Node的区别，只取一个，然后继续执行微任务队列中的任务
// 再去宏任务队列取一个，以此构成循环

// 4. NodeJs 可以理解有4个红任务队列2个微任务队列,但是执行宏任务有6个阶段。先执行全局Script代码，执行完同步代码调用栈清空后
// 从微任务队列中以此取出所有任务放入调用栈中执行。将宏任务队列中所有的任务都取出来执行，每个宏任务执行完毕后，开始执行微任务。
